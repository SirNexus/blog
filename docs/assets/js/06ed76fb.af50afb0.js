"use strict";(self.webpackChunkaidan_blog=self.webpackChunkaidan_blog||[]).push([[349],{3919:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var o=n(9281),i=n(4848),a=n(8453);const s={slug:"istio-pod-to-pod-mtls",title:"Enabling pod to pod mTLS in Istio",authors:"aidancarson",tags:["Istio","ServiceEntry","pod","mTLS","strict","authentication"]},r=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Imagine a situation where you have multiple different clusters, each running\nan Istio service mesh and which are federated together to talk to each other.\nNow also imagine that these clusters are networked together such that each\npod IP is uniquely addressable and able to be communicated with from any other\ncluster."}),"\n",(0,i.jsx)(t.p,{children:"I faced a situation like this, where I needed to group endpoints into logical\nhostnames that represented services backed by those endpoints. Because endpoints\ncould live anywhere, in any cluster, I landed on using a ServiceEntry to register\nthe hostname and WorkloadEntries to represent the endpoints service that hostname.\nThe configuration looked something like this:"}),"\n",(0,i.jsx)(t.p,{children:"ServiceEntry:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml"})}),"\n",(0,i.jsx)(t.p,{children:"WorkloadEntry:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml"})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(6540);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}},9281:e=>{e.exports=JSON.parse('{"permalink":"/blog/istio-pod-to-pod-mtls","source":"@site/blog/2025-04-29-istio-pod-to-pod-mtls/index.md","title":"Enabling pod to pod mTLS in Istio","description":"Imagine a situation where you have multiple different clusters, each running","date":"2025-04-29T00:00:00.000Z","tags":[{"inline":true,"label":"Istio","permalink":"/blog/tags/istio"},{"inline":true,"label":"ServiceEntry","permalink":"/blog/tags/service-entry"},{"inline":true,"label":"pod","permalink":"/blog/tags/pod"},{"inline":true,"label":"mTLS","permalink":"/blog/tags/m-tls"},{"inline":true,"label":"strict","permalink":"/blog/tags/strict"},{"inline":true,"label":"authentication","permalink":"/blog/tags/authentication"}],"readingTime":0.575,"hasTruncateMarker":false,"authors":[{"name":"Aidan Carson","key":"aidancarson","page":null}],"frontMatter":{"slug":"istio-pod-to-pod-mtls","title":"Enabling pod to pod mTLS in Istio","authors":"aidancarson","tags":["Istio","ServiceEntry","pod","mTLS","strict","authentication"]},"unlisted":false}')}}]);