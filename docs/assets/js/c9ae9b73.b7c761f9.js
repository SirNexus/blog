"use strict";(self.webpackChunkaidan_blog=self.webpackChunkaidan_blog||[]).push([[382],{3766:e=>{e.exports=JSON.parse('{"permalink":"/blog/kind-multi-cluster-flat-network","source":"@site/blog/2025-06-13-kind-multi-cluster-flat-network.md","title":"Networking Multiple Kind Kubernetes Clusters Together Using Native Routing","description":"Recently, I set out to create a multi-cluster kind environment where clusters could communicate over a flat network.","date":"2025-06-13T00:00:00.000Z","tags":[{"inline":true,"label":"Kind","permalink":"/blog/tags/kind"},{"inline":true,"label":"Kubernetes","permalink":"/blog/tags/kubernetes"},{"inline":true,"label":"Networking","permalink":"/blog/tags/networking"},{"inline":true,"label":"Pod","permalink":"/blog/tags/pod"},{"inline":true,"label":"Linux","permalink":"/blog/tags/linux"}],"readingTime":2.87,"hasTruncateMarker":true,"authors":[{"name":"Aidan Carson","key":"aidancarson","page":null}],"frontMatter":{"slug":"kind-multi-cluster-flat-network","title":"Networking Multiple Kind Kubernetes Clusters Together Using Native Routing","authors":"aidancarson","tags":["Kind","Kubernetes","Networking","Pod","Linux"],"toc_min_heading_level":2,"toc_max_heading_level":5},"unlisted":false,"nextItem":{"title":"Enabling pod to pod mTLS in Istio","permalink":"/blog/istio-pod-to-pod-mtls"}}')},4258:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var i=t(3766),o=t(4848),r=t(8453);const s={slug:"kind-multi-cluster-flat-network",title:"Networking Multiple Kind Kubernetes Clusters Together Using Native Routing",authors:"aidancarson",tags:["Kind","Kubernetes","Networking","Pod","Linux"],toc_min_heading_level:2,toc_max_heading_level:5},l=void 0,a={authorsImageUrls:[void 0]},d=[{value:"The Challenge",id:"the-challenge",level:2},{value:"Options Considered",id:"options-considered",level:2},{value:"Example Configuration",id:"example-configuration",level:2},{value:"Example Workflow",id:"example-workflow",level:2},{value:"Final Thoughts",id:"final-thoughts",level:2},{value:"A note for Cilium and service networking",id:"a-note-for-cilium-and-service-networking",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Recently, I set out to create a multi-cluster kind environment where clusters could communicate over a flat network.\nThe goal was simple: pods in one cluster should be able to directly talk to pods in another cluster without requiring tunneling or proxies."}),"\n",(0,o.jsx)(n.p,{children:"At first glance, this seemed tricky \u2014 the pod IPs assigned inside kind clusters exist only within the containerized\nnetwork of each cluster, and Docker isolates these networks by default. However, I eventually found a straightforward\nsolution that uses native routing, and I wanted to share my journey and what worked."}),"\n",(0,o.jsx)(n.h2,{id:"the-challenge",children:"The Challenge"}),"\n",(0,o.jsx)(n.p,{children:"By design, kind runs Kubernetes clusters inside Docker containers. This means:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Pod IPs are only visible inside the Docker network created for each kind cluster."}),"\n",(0,o.jsx)(n.li,{children:"There\u2019s no built-in way for a pod in one cluster to directly communicate with a pod in another cluster using its pod IP."}),"\n",(0,o.jsx)(n.li,{children:"Bridging these isolated networks requires either complex overlay solutions or manual routing."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"options-considered",children:"Options Considered"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Use Cilium Service Mesh"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"If you\u2019re okay with the added configuration and overhead, Cilium Service Mesh is a great choice:"}),"\n",(0,o.jsx)(n.li,{children:"It can establish a flat network across multiple clusters."}),"\n",(0,o.jsxs)(n.li,{children:["With ",(0,o.jsx)(n.a,{href:"https://docs.cilium.io/en/stable/network/clustermesh/affinity/#enabling-global-service-affinity",children:"Global Service Affinity"}),",\nservices in different clusters can even resolve each other\u2019s names and load balance between them."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Native Routing Using ip route (The solution that worked): manually add routes\nto each Docker container that runs a kind node."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Each node knows how to route pod traffic destined for another cluster\u2019s pod subnet."}),"\n",(0,o.jsx)(n.li,{children:"Traffic flows directly via the Docker bridge network, using the container IP of the appropriate node as the next hop."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For my use case, I wanted a lighter-weight solution that didn\u2019t require\ndeploying cilium cluster mesh, so I opted for the native routing approach."}),"\n",(0,o.jsx)(n.h2,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Here\u2019s an example kind config I used to define pod and service subnets:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n   - role: control-plane\n   - role: worker\n     networking:\n     disableDefaultCNI: true\n     podSubnet: "10.0.0.0/16"\n     serviceSubnet: "10.1.0.0/16"\n'})}),"\n",(0,o.jsx)(n.p,{children:"To make routing work, I added routes like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ip route add 10.0.0.0/16 via <docker-container-ip-of-cluster1-node>\nip route add 10.2.0.0/16 via <docker-container-ip-of-cluster2-node>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Each via IP corresponds to a Docker container (the kind node) that knows how to reach its local pod subnet."}),"\n",(0,o.jsx)(n.h2,{id:"example-workflow",children:"Example Workflow"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create two kind clusters with distinct pod subnets:"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Cluster A: 10.0.0.0/16"}),"\n",(0,o.jsx)(n.p,{children:"Cluster B: 10.2.0.0/16"}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsx)(n.li,{children:"Retrieve the Docker container IPs for the nodes in each cluster:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container-name>\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsx)(n.li,{children:"On each kind node container, add routes for the other cluster\u2019s pod subnet:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"docker exec <cluster-a-node> ip route add 10.2.0.0/16 via <cluster-b-node-ip>\ndocker exec <cluster-b-node> ip route add 10.0.0.0/16 via <cluster-a-node-ip>\n"})}),"\n",(0,o.jsx)(n.p,{children:"The Result: Pods in Cluster A can now talk to pods in Cluster B by pod IP, and vice versa!"}),"\n",(0,o.jsx)(n.h2,{id:"final-thoughts",children:"Final Thoughts"}),"\n",(0,o.jsx)(n.p,{children:"If you\u2019re experimenting with multi-cluster setups in a local or CI environment,\nthis native routing method is lightweight and effective. That said, for production-like features (service discovery, identity-aware routing, encryption), service mesh solutions like Cilium offer more power and flexibility."}),"\n",(0,o.jsx)(n.h2,{id:"a-note-for-cilium-and-service-networking",children:"A note for Cilium and service networking"}),"\n",(0,o.jsxs)(n.p,{children:["If you're using Cilium for your CNI, you'll want to use the ",(0,o.jsx)(n.code,{children:"bpf.lbExternalClusterIP"}),"\noption in helm. This will expose the cluster IPs to the host network on the nodes,\nallowing you to also address the service IPs from your other clusters."]}),"\n",(0,o.jsx)(n.p,{children:"Happy clustering! If you have any questions or suggestions, feel free to reach out."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);